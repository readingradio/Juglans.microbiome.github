library(VennDiagram)
quartz(); venn.diagram(in.hubs$name, wa.hubs$name, tn.hubs$name)
quartz(); venn.diagram(x = list(in.hubs$name, wa.hubs$name, tn.hubs$name), category.names=c("IN","WA","TN"))
quartz(); venn.diagram(x = list(in.hubs$name, wa.hubs$name, tn.hubs$name), category.names=c("IN","WA","TN"), filename="Figures/Soil.Net.Venn.png", output=T)
intersect(wa.hubs$name, in.hubs$name, tn.hubs$name)
intersect(wa.hubs$name, in.hubs$name) %>% intersect(tn.hubs$name)
intersect(wa.hubs$name, in.hubs$name)
in.hubs <- read.csv("Results/Shavings.HubOTUS.IN.csv")#
tn.hubs <- read.csv("Results/Shavings.HubOTUS.TN.csv")#
wa.hubs <- read.csv("Results/Shavings.HubOTUS.WA.csv")#
#
intersect(in.hubs$name, tn.hubs$name)#
intersect(wa.hubs$name, tn.hubs$name)#
intersect(wa.hubs$name, in.hubs$name)#
intersect(wa.hubs$name, in.hubs$name) %>% intersect(tn.hubs$name)
venn.diagram(x = list(in.hubs$name, wa.hubs$name, tn.hubs$name), category.names=c("IN","WA","TN"), filename="Figures/Shavings.Net.Venn.png", output=T)
otunames.rf <- read.csv("../../Results/RF.shavings.t.table.csv", row.names=1)
cur.s<-"IN"
setwd(paste("./Net.analysis/CorrNetworks.", cur.s, sep=""))
otunames.rf <- read.csv("../../Results/RF.shavings.t.table.csv", row.names=1)
otunames.rf[as.chacater(bd.tab$name),]
bd.tab <- read.csv(paste("../../Results/Shavings.HubOTUS.", cur.s, ".csv", sep=""))
bd.tab
otunames.rf[as.chacater(bd.tab$name),]
otunames.rf[as.character(bd.tab$name),]
otunames.rf
as.character(bd.tab$name)
x<- intersect(as.character(bd.tab$name), rownames(otunames.rf))
x
otunames.rf[x,]
otunames.rf[x,] %>% write.csv(., paste("../../Results/Shavings.HubOTUS.RF.consensus.", cur.s, ".csv", sep=""), quote=F, row.names=T)
cur.s<-"TN"
setwd("../..")
setwd(paste("./Net.analysis/CorrNetworks.", cur.s, sep=""))
bd.tab <- read.csv(paste("../../Results/Shavings.HubOTUS.", cur.s, ".csv", sep=""))
x<- intersect(as.character(bd.tab$name), rownames(otunames.rf))
otunames.rf[x,] %>% write.csv(., paste("../../Results/Shavings.HubOTUS.RF.consensus.", cur.s, ".csv", sep=""), quote=F, row.names=T)
otunames.rf[x,]
cur.s<-"WA"
setwd(paste("./Net.analysis/CorrNetworks.", cur.s, sep=""))
setwd("../..")
setwd(paste("./Net.analysis/CorrNetworks.", cur.s, sep=""))
bd.tab <- read.csv(paste("../../Results/Shavings.HubOTUS.", cur.s, ".csv", sep=""))
x<- intersect(as.character(bd.tab$name), rownames(otunames.rf))
otunames.rf[x,] %>% write.csv(., paste("../../Results/Shavings.HubOTUS.RF.consensus.", cur.s, ".csv", sep=""), quote=F, row.names=T)
otunames.rf[x,]
entropy
in.hubs <- read.csv("Results/Soils.HubOTUS.IN.csv")#
tn.hubs <- read.csv("Results/Soils.HubOTUS.TN.csv")#
wa.hubs <- read.csv("Results/Soils.HubOTUS.WA.csv")#
#
intersect(in.hubs$name, tn.hubs$name)#
intersect(wa.hubs$name, tn.hubs$name)#
intersect(wa.hubs$name, in.hubs$name)#
intersect(wa.hubs$name, in.hubs$name) %>% intersect(tn.hubs$name)
setwd("../..")
in.hubs <- read.csv("Results/Soils.HubOTUS.IN.csv")#
tn.hubs <- read.csv("Results/Soils.HubOTUS.TN.csv")#
wa.hubs <- read.csv("Results/Soils.HubOTUS.WA.csv")#
#
intersect(in.hubs$name, tn.hubs$name)#
intersect(wa.hubs$name, tn.hubs$name)#
intersect(wa.hubs$name, in.hubs$name)#
intersect(wa.hubs$name, in.hubs$name) %>% intersect(tn.hubs$name)
citation(QuACN)
citation('QuACN')
citation('acss')
list("hello", 1, TRUE)
length(list("hello", 1, TRUE))
?sample
sample(8)
sample(9)
sample(2)
sample(3)
sample(4)
sample(5)
sample(6)
sample(7)
sample(7,1)
sample(7,2)
is.null(NULL)
?sample
sample(rows)
summaryBy
library(doBy)
?summaryBy
m <- matrix(4,4, sample(16))
m
m <- matrix(sample(16),4,4)
m
v <- sample(4)
v <- sample(3)
m <- m[v,v]
m
setwd(".")#
#
library(tidyr)#
library(Hmisc)#
library(MASS)#
library(igraph)#
library(tidygraph)#
library(ggraph)#
library(gridExtra)#
library(QuACN)#
library(acss)
source("Net.complex.functions.R")
out <-NULL
p<-"0.6"
r <- "0.05"
IN <- read.network (p, r, "IN", subs=T, tissue="shavings", path = ".")
getwd()
dir("Net.analysis/CorrNetworks.IN")
p <- "0.05"
r<-"0.6"
IN <- read.network (p, r, "IN", subs=T, tissue="shavings", path = ".")
TN <- read.network (p, r, "TN", subs=T, tissue="shavings", path = ".")
WA <- read.network (p, r, "WA", subs=T, tissue="shavings", path = ".")
out <- rbind(out, cbind(data.frame(P = rep(p, 3), R = rep(r, 3)), compare.networks(list(IN,TN,WA))))
source("Net.complex.functions.R")
out <- rbind(out, cbind(data.frame(P = rep(p, 3), R = rep(r, 3)), compare.networks(list(IN,TN,WA))))
IN
adj.mat(IN) %>% as.matrix() %>% as(., "graphNEL")
as.adj(IN) %>% as.matrix() %>% as(., "graphNEL")
as_adj(IN) %>% as.matrix() %>% as(., "graphNEL")
as_adj(IN) %>% as(., "graphNEL")
source("Net.complex.functions.R")
out <- rbind(out, cbind(data.frame(P = rep(p, 3), R = rep(r, 3)), compare.networks(list(IN,TN,WA))))
source("Net.complex.functions.R")
out <- rbind(out, cbind(data.frame(P = rep(p, 3), R = rep(r, 3)), compare.networks(list(IN,TN,WA))))
IN
g <- list(IN, TN, WA)
sizes<-NULL; for (i in 1:length(g)) sizes <- c(sizes, (as_adj(g[[i]]) %>% as.matrix() %>% dim())[1])
sizes
cutoff.size <- ( min(sizes) %/% bs ) * bs
cutoff.size <- ( min(sizes) %/% 4 ) * 4
cutoff.size
i<1
i<-1
m <- as_adj(g[[i]]) %>% as.matrix()
m
v <- sample (sizes[i])							# create a vector to randomly permute the rows and columns together in the same order
v
m <- m[v,v] 										# randomly permute the rows and columns
m
dim(m)
v
m <- as_adj(g[[i]]) %>% as.matrix()
row.names(m)
m <- m[v,v] 										# randomly permute the rows and columns
row.names(m)
start <- sample(sizes[i] - cutoff.size, 1)		# randomly choose what index to start random block of size = cutoff.size from the permuted matrix
start
indices <- start:(start + cutoff.size - 1)		# figure out what index to end and make vector of indices to use for subsample
indices
317-78
78:317
78:317 %>% length()
subm <- m[indices,indices]						# take out random block of size = cutoff.size from the permuted matrix
subm %>% dim()
analyze.network(adj.mat = subm)
source("Net.complex.functions.R")
analyze.network(adj.mat = subm)
source("Net.complex.functions.R")
analyze.network(adj.mat = subm)
out <- NULL#
		for (i in 1:length(g)) {#
			m <- as_adj(g[[i]]) %>% as.matrix()#
			v <- sample (sizes[i])							# create a vector to randomly permute the rows and columns together in the same order#
			m <- m[v,v] 										# randomly permute the rows and columns#
			start <- sample(sizes[i] - cutoff.size, 1)		# randomly choose what index to start random block of size = cutoff.size from the permuted matrix#
			indices <- start:(start + cutoff.size - 1)		# figure out what index to end and make vector of indices to use for subsample#
			subm <- m[indices,indices]						# take out random block of size = cutoff.size from the permuted matrix#
			out <- rbind(out, cbind(data.frame(State = (names(g))[i]), analyze.network(adj.mat = subm)))		# analyze randomly subsetted matrix#
		}#
		out
data.frame(State = (names(g))[i])
names(g)
g
states <- list(IN,TN,WA)
names(states) <- c("IN", "TN", "WA")
g <- states
g
out <- NULL#
		for (i in 1:length(g)) {#
			m <- as_adj(g[[i]]) %>% as.matrix()#
			v <- sample (sizes[i])							# create a vector to randomly permute the rows and columns together in the same order#
			m <- m[v,v] 										# randomly permute the rows and columns#
			start <- sample(sizes[i] - cutoff.size, 1)		# randomly choose what index to start random block of size = cutoff.size from the permuted matrix#
			indices <- start:(start + cutoff.size - 1)		# figure out what index to end and make vector of indices to use for subsample#
			subm <- m[indices,indices]						# take out random block of size = cutoff.size from the permuted matrix#
			out <- rbind(out, cbind(data.frame(State = (names(g))[i]), analyze.network(adj.mat = subm)))		# analyze randomly subsetted matrix#
		}#
		out
boot.out <- foreach (Try=1:20, .combine=rbind) %dopar% {#
		out <- NULL#
		for (i in 1:length(g)) {#
			m <- as_adj(g[[i]]) %>% as.matrix()#
			v <- sample (sizes[i])							# create a vector to randomly permute the rows and columns together in the same order#
			m <- m[v,v] 										# randomly permute the rows and columns#
			start <- sample(sizes[i] - cutoff.size, 1)		# randomly choose what index to start random block of size = cutoff.size from the permuted matrix#
			indices <- start:(start + cutoff.size - 1)		# figure out what index to end and make vector of indices to use for subsample#
			subm <- m[indices,indices]						# take out random block of size = cutoff.size from the permuted matrix#
			out <- rbind(out, cbind(data.frame(State = (names(g))[i]), analyze.network(adj.mat = subm)))		# analyze randomly subsetted matrix#
		}#
		out#
	}#
#
	# now return mean and standard error for each of the metrics for each matrix by its name#
	summaryBy( . ~ State, boot.out, FUN = c(mean, sd) )
source("Net.complex.functions.R")
out <-NULL#
#
for (p in c("0.05","0.01","0.005", "0.001")) {#
  for (r in c("0.6","0.8")) {#
  	IN <- read.network (p, r, "IN", subs=T, tissue="shavings", path = ".")#
	TN <- read.network (p, r, "TN", subs=T, tissue="shavings", path = ".")#
  	WA <- read.network (p, r, "WA", subs=T, tissue="shavings", path = ".")#
  	states <- list(IN,TN,WA)#
  	names(states) <- c("IN", "TN", "WA")#
  	out <- rbind(out, cbind(data.frame(P = rep(p, 3), R = rep(r, 3)), compare.networks()))#
}}
out <-NULL#
#
for (p in c("0.05","0.01","0.005", "0.001")) {#
  for (r in c("0.6","0.8")) {#
  	IN <- read.network (p, r, "IN", subs=T, tissue="shavings", path = ".")#
	TN <- read.network (p, r, "TN", subs=T, tissue="shavings", path = ".")#
  	WA <- read.network (p, r, "WA", subs=T, tissue="shavings", path = ".")#
  	states <- list(IN,TN,WA)#
  	names(states) <- c("IN", "TN", "WA")#
  	out <- rbind(out, cbind(data.frame(P = rep(p, 3), R = rep(r, 3)), compare.networks(states)))#
}}
out$P <- out$P %>% as.character() %>% as.numeric()
out
compare.networks(states)
states
source("Net.complex.functions.R")
states
compare.networks(states)
source("Net.complex.functions.R")
out <-NULL#
#
for (p in c("0.05","0.01","0.005", "0.001")) {#
  for (r in c("0.6","0.8")) {#
  	IN <- read.network (p, r, "IN", subs=T, tissue="shavings", path = ".")#
	TN <- read.network (p, r, "TN", subs=T, tissue="shavings", path = ".")#
  	WA <- read.network (p, r, "WA", subs=T, tissue="shavings", path = ".")#
  	states <- list(IN,TN,WA)#
  	names(states) <- c("IN", "TN", "WA")#
  	out <- rbind(out, cbind(data.frame(P = rep(p, 3), R = rep(r, 3)), compare.networks(states)))#
}}
out$P <- out$P %>% as.character() %>% as.numeric()
out
expression("Kolmogorov.mean")
arrows
?arrows
matrix(1:6,nrow=2)
matrix(1:6,nrow=2) %>% plot()
matrix(1:6,ncol=2) %>% plot()
matrix(1:6,ncol=2)
quartz
quartz()
x<-out
x
stat<-"Kolmogorov"
s.m <- paste(stat, "mean", sep=".")
s.s <- paste(stat, "sd", ".")
x$y1 <- x[,s.m] - x[,s.s]
x[,s.m]
x[,s.s]
s.s
s.s <- paste(stat, "sd", sep=".")
x$y1 <- x[,s.m] - x[,s.s]
x$y2 <- x[,s.m] + x[,s.s]
x[x$Name=="IN" & x$R == 0.8, c("P", s.m)] %>% plot(lty=1, type="b", ylim=c(0,max(x$Kolmogorov)))
x[x$Name=="IN" & x$R == 0.8, c("P", s.m)]
x[x$Name=="IN" & x$R == 0.8, c("P", s.m)] %>% plot()
x[x$Name=="IN" & x$R == 0.8, c("P", s.m)] %>% plot(lty=1, type="b", ylim=c(0,max(x$y2)))
x[x$Name=="TN" & x$R == 0.8, c("P", s.m)] %>% lines(lty = 2, type="b")
x[x$Name=="WA" & x$R == 0.8, c("P", s.m)] %>% lines(lty = 3, type="b")
x[x$Name=="IN" & x$R == 0.6, c("P", s.m)] %>% lines(lty = 1, type="b", pch=2)
x[x$Name=="TN" & x$R == 0.6, c("P", s.m)] %>% lines(lty = 2, type="b", pch=2)
x[x$Name=="WA" & x$R == 0.6, c("P", s.m)] %>% lines(lty = 3, type="b", pch=2)
x[x$Name=="IN" & x$R == 0.8, c("P", s.m, "P", y1)] %>% arrows(angle=90)
x[x$Name=="IN" & x$R == 0.8, c("P", s.m, "P", "y1")] %>% arrows(angle=90)
x[x$Name=="IN" & x$R == 0.8, c("P", s.m, "P", "y1")]
matrix(1:12,ncol=2)
matrix(1:12,ncol=4)
matrix(1:12,ncol=4) %>% arrows()
?arrows
x[x$Name=="IN" & x$R == 0.8, c("P", s.m, "P", "y1")] %>% arrows(.,angle=90)
arrows(x[x$Name=="IN" & x$R == 0.8, c("P", s.m, "P", "y1")])
matrix(1:12,ncol=4) %>% arrows(.[1], .[2], .[3], .[4])
x[x$Name=="IN" & x$R == 0.8, c("P", s.m, "P", "y1")] %>% arrows(.[1], .[2], .[3], .[4], angle=90)
x[x$Name=="IN" & x$R == 0.8, c("P", s.m, "P", "y1")] %>% arrows(., .[3], .[4], angle=90)
for (a in c("IN", "TN", "WA")) for (b in c(.8, .6)) for (c in c("y1", "y2")) x[x$Name==a & x$R=b,"P"] %>% arrows(., x[x$Name==a & x$R=b,sm], ., x[x$Name==a & x$R=b,c], angle=90)
for (a in c("IN", "TN", "WA")) for (b in c(.8, .6)) for (c in c("y1", "y2")) x[x$Name==a & x$R==b,"P"] %>% arrows(., x[x$Name==a & x$R==b,sm], ., x[x$Name==a & x$R==b,c], angle=90)
for (a in c("IN", "TN", "WA")) for (b in c(.8, .6)) for (c in c("y1", "y2")) x[x$Name==a & x$R==b,"P"] %>% arrows(., x[x$Name==a & x$R==b,s.m], ., x[x$Name==a & x$R==b,c], angle=90)
x[x$Name=="IN" & x$R == 0.8, c("P", s.m)] %>% plot(lty=1, type="b", ylim=c(0,max(x$y2)))#
	x[x$Name=="TN" & x$R == 0.8, c("P", s.m)] %>% lines(lty = 2, type="b")#
	x[x$Name=="WA" & x$R == 0.8, c("P", s.m)] %>% lines(lty = 3, type="b")#
	x[x$Name=="IN" & x$R == 0.6, c("P", s.m)] %>% lines(lty = 1, type="b", pch=2)#
	x[x$Name=="TN" & x$R == 0.6, c("P", s.m)] %>% lines(lty = 2, type="b", pch=2)#
	x[x$Name=="WA" & x$R == 0.6, c("P", s.m)] %>% lines(lty = 3, type="b", pch=2)#
	for (a in c("IN", "TN", "WA")) for (b in c(.8, .6)) for (c in c("y1", "y2")) x[x$Name==a & x$R==b,"P"] %>% arrows(., x[x$Name==a & x$R==b,s.m], ., x[x$Name==a & x$R==b,c], angle=90, length=.025)
source("Net.complex.functions.R")
network.complexity.plot(out, "Entropy")
source("Net.complex.functions.R")
network.complexity.plot(out, "Entropy")
legend(NA, legend=c("IN","TN","WA","R=0.8","R=0.6"), lty=c(1,2,3,NA,NA), pch=c(NA,NA,NA,1,2))
source("Net.complex.functions.R")
network.complexity.plot(out, "Entropy")
out
network.complexity.plot(out, "Entropy", "bottomleft")
network.complexity.plot(out, "Entropy", leg="bottomleft")
network.complexity.plot(out, "Shannon.2nd", leg="bottomleft")
network.complexity.plot(out, "Shannon.2nd", leg="topright")
network.complexity.plot(out, "Shannon.2nd", leg="topleft")
source("Net.complex.functions.R")
net.complex.multipanel (out)
out %>% write.csv("Results/Network.complexity.caulosphere.csv")
out <-NULL#
#
for (p in c("0.05","0.01","0.005", "0.001")) {#
  for (r in c("0.6","0.8")) {#
  	IN <- read.network (p, r, "IN", subs=T, tissue="soils", path = ".")#
	TN <- read.network (p, r, "TN", subs=T, tissue="soils", path = ".")#
  	WA <- read.network (p, r, "WA", subs=T, tissue="soils", path = ".")#
  	states <- list(IN,TN,WA)#
  	names(states) <- c("IN", "TN", "WA")#
  	out <- rbind(out, cbind(data.frame(P = rep(p, 3), R = rep(r, 3)), compare.networks(states)))#
}}#
#
out$P <- out$P %>% as.character() %>% as.numeric()#
#
out %>% write.csv("Results/Network.complexity.soil.csv")#
#
save.image("R_Environments/Soil.net.stats.RData")#
#
quartz()#
net.complex.multipanel (out)
out <-NULL#
#
for (p in c( "0.00005", "0.00001","0.000005","0.000001")) {#
  for (r in c("0.6","0.8")) {#
  	IN <- read.network (p, r, "IN", subs=T, tissue="soils", path = ".")#
	TN <- read.network (p, r, "TN", subs=T, tissue="soils", path = ".")#
  	WA <- read.network (p, r, "WA", subs=T, tissue="soils", path = ".")#
  	states <- list(IN,TN,WA)#
  	names(states) <- c("IN", "TN", "WA")#
  	out <- rbind(out, cbind(data.frame(P = rep(p, 3), R = rep(r, 3)), compare.networks(states)))#
}}#
#
out$P <- out$P %>% as.character() %>% as.numeric()#
#
out %>% write.csv("Results/Network.complexity.soil.csv")#
#
save.image("R_Environments/Soil.net.stats.RData")#
#
quartz()#
net.complex.multipanel (out)
source("Net.complex.functions.R")
out
out[out$P<0.5,]
out[out$P<0.0005,]
out[out$P<0.00005,]
net.complex.multipanel (out[out$P<0.00005,])
load("R_Environments/Caulo.net.stats.RData")
out
quartz()
net.complex.multipanel (out[out$P<0.00005,])
net.complex.multipanel (out[out$P<0.05,])
out[out$P<0.05,]
net.complex.multipanel (out[out$P<0.05,])
out[out$P<0.05,]
net.complex.multipanel (out)
source("Net.complex.functions.R")
net.complex.multipanel (out)
out <- read.csv("Results/Network.complexity.caulosphere.csv")
out
out <- read.csv("Results/Network.complexity.caulosphere.csv", row.names=F)
out <- read.csv("Results/Network.complexity.caulosphere.csv", rownames=F)
out <- read.csv("Results/Network.complexity.caulosphere.csv")[,-1]
out
save.image("R_Environments/Caulo.net.stats.RData")
net.complex.multipanel (out)
source("Net.complex.functions.R")
net.complex.multipanel (out[out$P<0.05,])
source("Net.complex.functions.R")
net.complex.multipanel (out[out$P<0.05,])
